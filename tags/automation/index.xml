<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>automation on On The Dock</title>
    <link>https://onthedock.github.io/tags/automation/</link>
    <description>Recent content in automation on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <lastBuildDate>Sat, 12 Feb 2022 15:39:46 +0100</lastBuildDate><atom:link href="https://onthedock.github.io/tags/automation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GitOps con ArgoCD - Instalación y acceso a la consola</title>
      <link>https://onthedock.github.io/post/220212-instalacion-y-acceso-a-la-consola/</link>
      <pubDate>Sat, 12 Feb 2022 15:39:46 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/220212-instalacion-y-acceso-a-la-consola/</guid>
      <description>&lt;p&gt;GitOps es una forma de gestionar los clústers de Kubernetes y el proceso de &lt;em&gt;application delivery&lt;/em&gt;, según consta en la definición que hacen los inventores del término, el equipo de Weave.works en &lt;a href=&#34;https://www.weave.works/technologies/gitops/&#34;&gt;What is GitOps?&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El concepto &lt;em&gt;gitOps&lt;/em&gt; proporciona un modelo operativo en el que &lt;em&gt;el estado deseado&lt;/em&gt; del clúster (y de las aplicaciones desplegadas en él) se encuentra definido de forma &lt;strong&gt;declarativa&lt;/strong&gt; en un repositorio Git.&lt;/p&gt;
&lt;p&gt;Un agente se encarga de reconciliar el &lt;em&gt;estado deseado&lt;/em&gt; (en Git) con el &lt;em&gt;estado real&lt;/em&gt; (en Kubernetes), considerando -en general- como &lt;strong&gt;fuente de la verdad&lt;/strong&gt; el contenido del repositorio.&lt;/p&gt;
&lt;p&gt;Aunque Weave.works desarrolló inicialmente &lt;a href=&#34;https://fluxcd.io/&#34;&gt;Flux&lt;/a&gt; (ahora forma parte de la CNCF), en este &lt;em&gt;post&lt;/em&gt; hablaré de &lt;a href=&#34;https://argo-cd.readthedocs.io/en/stable/&#34;&gt;ArgoCD&lt;/a&gt;. Hay otras herramientas con las que implementar GitOps, pero sin duda Flux y ArgoCD son las referencias indiscutibles.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Crear usuarios (usando recursos nativos) en Kubernetes 1.19&#43;</title>
      <link>https://onthedock.github.io/post/211205-crear-usuarios-usando-recursos-nativos-en-kubernetes-1.19/</link>
      <pubDate>Sun, 05 Dec 2021 19:57:28 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/211205-crear-usuarios-usando-recursos-nativos-en-kubernetes-1.19/</guid>
      <description>&lt;p&gt;Hace unas entradas, en &lt;a href=&#34;https://onthedock.github.io/post/211010-crear-usuarios-en-k3s/&#34;&gt;
Crear usuarios en Kubernetes (y en K3s)&lt;/a&gt;, escribía sobre cómo generar nuevos usuarios con acceso al clúster de Kubernetes usando un fichero &lt;code&gt;kubeconfig&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;El método descrito implicaba extraer fuera del clúster el certificado privado de la entidad certificadora (CA) de Kubernetes, lo que no me parecía la mejor solución.&lt;/p&gt;
&lt;p&gt;Desde Kubernetes 1.19 existe un nuevo recurso en la API, el &lt;code&gt;CertificateSigningRequest&lt;/code&gt;, que permite firmar certificados para proporcionar acceso (por ejemplo) al clúster.&lt;/p&gt;
&lt;p&gt;En esta entrada se describe cómo aprovechar esta nueva funcionalidad para dar acceso a un usuario usando un certificado firmado por la CA del clúster.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Prueba de Concepto de notificaciones via CloudWatch Events desde CloudFormation (sin Lambdas)</title>
      <link>https://onthedock.github.io/post/200510-prueba-de-concepto-de-notificaciones-via-sns-para-cfn/</link>
      <pubDate>Sun, 10 May 2020 00:42:51 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/200510-prueba-de-concepto-de-notificaciones-via-sns-para-cfn/</guid>
      <description>&lt;p&gt;En la entrada &lt;a href=&#34;https://onthedock.github.io/post/200507-envio-de-eventos-de-cfn-a-cwevents/&#34;&gt;Envío de eventos de CloudFormation a CloudWatch Events&lt;/a&gt; explicaba una manera alternativa -sin Lambdas- para enviar notificaciones SNS con información de ARNs de recursos generados en CloudFormation a través de CloudWatch Events.&lt;/p&gt;
&lt;p&gt;En esta entrada explico cómo he realizado una prueba de concepto para validar que es viable.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Automatizando la configuracion de una VM para Ansible</title>
      <link>https://onthedock.github.io/post/181216-automatizando-la-configuracion-previa-de-una-vm-para-ansible/</link>
      <pubDate>Sun, 16 Dec 2018 13:55:30 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/181216-automatizando-la-configuracion-previa-de-una-vm-para-ansible/</guid>
      <description>&lt;p&gt;Con Ansible podemos automatizar la gestión de la configuración de las máquinas virtuales (o no) que creamos. Pero para poder explotar la potencia de Ansible necesitamos que la máquina gestionada cumpla unos requisitos previos: disponer de Python 2.6 o superior y que Ansible pueda conectar con la máquina.&lt;/p&gt;
&lt;p&gt;Todas estas tareas se pueden automatizar, así que vamos a ver cómo conseguirlo.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Automatizando la instalación de Gitea (con Docker Compose)</title>
      <link>https://onthedock.github.io/post/180715-automatizando-gitea-con-docker-compose/</link>
      <pubDate>Sun, 15 Jul 2018 11:35:54 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/180715-automatizando-gitea-con-docker-compose/</guid>
      <description>&lt;p&gt;En la &lt;a href=&#34;https://onthedock.github.io/post/180715-automatizando-gitea-sin-docker-compose/&#34;&gt;entrada anterior&lt;/a&gt; explicaba cómo automatizar la instalación de Gitea usando un script y Docker.&lt;/p&gt;
&lt;p&gt;Todos los pasos necesarios para crear los volúmenes de datos, la &lt;em&gt;red interna&lt;/em&gt; entre Gitea y la base de datos, etc usan Docker.&lt;/p&gt;
&lt;p&gt;En esta entrada usaremos &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt; para obtener el mismo resultado y analizar las diferencias entre los dos métodos de instalación.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Error `File already exists` al ejecutar vagrant package</title>
      <link>https://onthedock.github.io/post/180120-error-file-already-exists-al-ejecutar-vagrant-package/</link>
      <pubDate>Sat, 20 Jan 2018 22:01:35 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/180120-error-file-already-exists-al-ejecutar-vagrant-package/</guid>
      <description>&lt;p&gt;La manera más sencilla de crear una &lt;em&gt;box&lt;/em&gt; personalizada para Vagrant es reutilizar una máquina virtual ya creada con Vagrant. Para facilitar este proceso, Vagrant proporciona el comando &lt;code&gt;package&lt;/code&gt;, que &lt;em&gt;empaqueta&lt;/em&gt; una máquina virtual existente en el formato &lt;em&gt;box&lt;/em&gt; de Vagrant.&lt;/p&gt;
&lt;p&gt;En esta entrada comento los pasos que hay que realizar paso a paso para crear una &lt;em&gt;box&lt;/em&gt; personalizada. También indico el origen y cómo solucionar el error &lt;code&gt;File already exists&lt;/code&gt; que he encontrado al ejecutar &lt;code&gt;vagrant package&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Instalando Docker-CE usando Vagrant shell provisioning</title>
      <link>https://onthedock.github.io/post/180114-instalando-docker-ce-usando-vagrant-shell-provisioning/</link>
      <pubDate>Sun, 14 Jan 2018 21:11:00 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/180114-instalando-docker-ce-usando-vagrant-shell-provisioning/</guid>
      <description>&lt;p&gt;A raíz de las pruebas realizadas en la &lt;a href=&#34;https://onthedock.github.io/post/180114-vagrant-segunda-oportunidad/&#34;&gt;segunda toma de contacto&lt;/a&gt; con &lt;!-- raw HTML omitted --&gt;Vagrant&lt;!-- raw HTML omitted --&gt;, he creado un script para instalar Docker-CE como &lt;strong&gt;prueba de concepto&lt;/strong&gt; de &lt;em&gt;shell provisioning&lt;/em&gt; sobre Vagrant.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;En vez de instalar una y otra vez Docker desde los repositorios, es mucho más eficiente crear una &lt;a href=&#34;https://www.vagrantup.com/docs/boxes/base.html&#34;&gt;&lt;em&gt;box&lt;/em&gt; personalizada&lt;/a&gt; con el software que necesitamos.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Vagrant: Segunda oportunidad (y mejores sensaciones que la primera vez)</title>
      <link>https://onthedock.github.io/post/180114-vagrant-segunda-oportunidad/</link>
      <pubDate>Sun, 14 Jan 2018 17:28:40 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/180114-vagrant-segunda-oportunidad/</guid>
      <description>&lt;p&gt;Después de una &lt;a href=&#34;https://onthedock.github.io/post/170521-vagrant-primeras-impresiones/&#34;&gt;primera toma de contacto&lt;/a&gt; con sabor agridulce, estos días festivos he dedicado algo más de tiempo a dar una segunda oportunidad a Vagrant.&lt;/p&gt;
&lt;p&gt;En este artículo recojo mis impresiones en esta nueva toma de contacto.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
