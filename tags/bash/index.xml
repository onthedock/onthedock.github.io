<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on On The Dock</title>
    <link>https://onthedock.github.io/tags/bash/</link>
    <description>Recent content in Bash on On The Dock</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <lastBuildDate>Sun, 09 Feb 2025 17:18:18 +0100</lastBuildDate>
    <atom:link href="https://onthedock.github.io/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PubSub con NATS y Bash (II)</title>
      <link>https://onthedock.github.io/post/250209-pubsub-con-nats-y-bash-ii/</link>
      <pubDate>Sun, 09 Feb 2025 17:18:18 +0100</pubDate>
      <guid>https://onthedock.github.io/post/250209-pubsub-con-nats-y-bash-ii/</guid>
      <description>&lt;p&gt;He estado pensando en algunas mejoras con respecto al uso de NATS para montar un sistema de pipelines basado en las ideas de la entrada anterior &lt;a href=&#34;https://onthedock.github.io/post/250208-pubsub-con-nats-y-bash/&#34;&gt;PubSub con NATS y Bash&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PubSub con NATS y Bash</title>
      <link>https://onthedock.github.io/post/250208-pubsub-con-nats-y-bash/</link>
      <pubDate>Sat, 08 Feb 2025 22:22:53 +0100</pubDate>
      <guid>https://onthedock.github.io/post/250208-pubsub-con-nats-y-bash/</guid>
      <description>&lt;p&gt;Bash es increiblemente permisivo, por lo que se ha convertido en mi lenguaje de &lt;em&gt;prototipado&lt;/em&gt; por defecto.&#xA;Combinado con SQLite y Jq, me faltaba una última pieza para completar los diseños: un sistema &lt;em&gt;pubsub&lt;/em&gt;.&#xA;Ahora he encontrado una manera sencilla de integrar NATS (corriendo en Docker) con Bash.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Define parámetros para tus scripts en Bash 3 con argparse-sh</title>
      <link>https://onthedock.github.io/post/250121-define-parametros-para-tus-scripts-en-bash3-con-argparse3-sh/</link>
      <pubDate>Tue, 21 Jan 2025 18:04:22 +0100</pubDate>
      <guid>https://onthedock.github.io/post/250121-define-parametros-para-tus-scripts-en-bash3-con-argparse3-sh/</guid>
      <description>&lt;p&gt;Hace un tiempo encontré el repositorio &lt;a href=&#34;https://github.com/yaacov/argparse-sh&#34;&gt;yaacov/argparse-sh&lt;/a&gt;, del autor del artículo &lt;a href=&#34;https://medium.com/@kobi.zamir/argparse-sh-simple-yet-powerful-bash-argument-parsing-124bad97d926&#34;&gt;argparse.sh: Simple Yet Powerful Bash argument parsing&lt;/a&gt;.&#xA;Como indica en el &lt;em&gt;post&lt;/em&gt;, &lt;code&gt;argparse-sh&lt;/code&gt; es una forma sencilla y potente de gestionar parámetros en Bash.&lt;/p&gt;&#xA;&lt;p&gt;La idea en la que se basa, creando un &lt;em&gt;array asociativo&lt;/em&gt; (un &lt;code&gt;dictionary&lt;/code&gt; en Python), me recordó a &lt;a href=&#34;https://cobra.dev/&#34;&gt;Cobra&lt;/a&gt;, en Go.&#xA;Pese a ser una &lt;em&gt;library&lt;/em&gt; pequeña, permite definir parámetros obligatorios y opcionales, un mensaje de ayuda para cada parámetro, diferentes tipos de parámetros&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;La &amp;ldquo;&lt;em&gt;única pega&lt;/em&gt;&amp;rdquo; es que, debido a que usa &lt;em&gt;arrays asociativos&lt;/em&gt;, require Bash 4 o superior.&lt;/p&gt;&#xA;&lt;p&gt;Así que me puse &lt;em&gt;manos a la obra&lt;/em&gt; para hacer un &lt;em&gt;backport&lt;/em&gt; y hacerlo compatible con Bash 3 (la que hay &lt;em&gt;por defecto&lt;/em&gt; en los Mac).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Google Cloud Workstation Manager - Un script para gestionar Cloud Workstations en Google Cloud</title>
      <link>https://onthedock.github.io/post/241102-cloud-workstation-manager/</link>
      <pubDate>Sat, 02 Nov 2024 17:21:51 +0100</pubDate>
      <guid>https://onthedock.github.io/post/241102-cloud-workstation-manager/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/workstations&#34;&gt;Cloud Workstations&lt;/a&gt; nos permite tener la misma máquina a todos los miembros del equipo, independientemente de si usamos un Mac o un equipo con Windows.&#xA;Partiendo de una imagen de contenedor, podemos desplegar una máquina virtual y usar Code OSS (la versión &lt;em&gt;open source&lt;/em&gt; de Visual Studio Code) con las mismas extensiones pre-instaladas, la misma configuración, etc&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;Quiero presentar el &lt;em&gt;script&lt;/em&gt; a mis compañeros antes de subirlo a Github, así que en la entrada de hoy me voy a centrar en explicar cómo he simplificado el número de parámetros requeridos para gestionar (crear/arrancar/detener/eliminar) una &lt;em&gt;workstation&lt;/em&gt; sin tener que recordar (o conocer) el nombre del clúster, de la configuración usada, etc&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unmarshal JSON en Bash (Parte II)</title>
      <link>https://onthedock.github.io/post/241006-unmarshal-json-en-bash-ii/</link>
      <pubDate>Sun, 06 Oct 2024 11:24:31 +0200</pubDate>
      <guid>https://onthedock.github.io/post/241006-unmarshal-json-en-bash-ii/</guid>
      <description>&lt;p&gt;Este artículo es la segunda parte de &lt;a href=&#34;https://onthedock.github.io/post/241005-unmarshal-json-en-bash-i/&#34;&gt;Unmarshal JSON en Bash (Parte I)&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Al final de la primera parte vimos cómo el MVP (&lt;em&gt;minimum viable product&lt;/em&gt;) no producía el resultado esperado para &lt;em&gt;keys&lt;/em&gt; en el documento JSON cuyo valor es un &lt;em&gt;array&lt;/em&gt; o un &lt;em&gt;object&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;En esta segunda parte, vamos a resolver este problema.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unmarshal JSON en Bash (Parte I)</title>
      <link>https://onthedock.github.io/post/241005-unmarshal-json-en-bash-i/</link>
      <pubDate>Sat, 05 Oct 2024 20:17:43 +0200</pubDate>
      <guid>https://onthedock.github.io/post/241005-unmarshal-json-en-bash-i/</guid>
      <description>&lt;p&gt;&lt;em&gt;Unmarshal&lt;/em&gt; es uno de esos verbos ingleses que es difícil de traducir al castellano, al menos para mí.&#xA;Según Google, sería algo así como &amp;ldquo;&lt;a href=&#34;https://www.google.com/search?q=to+unmarshal+in+spanish&#34;&gt;desmantelar&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;&#xA;&lt;p&gt;Aplicado a la programación, &amp;ldquo;to unmarshal&amp;rdquo; está relacionado con la idea de que, partiendo de un contenido ordenado, en JSON, &lt;em&gt;desperdigamos&lt;/em&gt; su contenido en variables que podemos utilizar en nuestra aplicación.&lt;/p&gt;&#xA;&lt;p&gt;Go, por ejemplo, proporciona la función &lt;a href=&#34;https://pkg.go.dev/encoding/json#Unmarshal&#34;&gt;Unmarshal&lt;/a&gt;, sin embargo en Bash, no he encontrado nada parecido.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Agrega una línea a un fichero sólo si no está presente #TIL</title>
      <link>https://onthedock.github.io/post/230713-agrega-linea-a-un-fichero-solo-si-no-esta-presente/</link>
      <pubDate>Thu, 13 Jul 2023 23:27:08 +0200</pubDate>
      <guid>https://onthedock.github.io/post/230713-agrega-linea-a-un-fichero-solo-si-no-esta-presente/</guid>
      <description>&lt;p&gt;Ayer estaba revisando un &lt;em&gt;script&lt;/em&gt; desarrollado por un compañero y me llamó la atención la manera en la que solucionaba un problema &amp;ldquo;habitual&amp;rdquo;: ¿cómo añadir una línea a un fichero &lt;em&gt;sólo si no está ya presente&lt;/em&gt;?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Clúster de K3s: actualización del script de despliegue</title>
      <link>https://onthedock.github.io/post/230108-actualizando-el-script-de-despliegue-del-cluster-de-k3s/</link>
      <pubDate>Sun, 08 Jan 2023 13:35:14 +0100</pubDate>
      <guid>https://onthedock.github.io/post/230108-actualizando-el-script-de-despliegue-del-cluster-de-k3s/</guid>
      <description>&lt;p&gt;Después de un tiempo focalizado casi exclusivamente en aprender Go, hoy he vuelto a &lt;em&gt;mis raíces&lt;/em&gt;: Kubernetes.&lt;/p&gt;&#xA;&lt;p&gt;En el repositorio &lt;a href=&#34;https://github.com/onthedock/vagrant&#34;&gt;onthedock/vagrant&lt;/a&gt; tengo los &lt;em&gt;scripts&lt;/em&gt; que me permiten desplegar varias máquinas virtuales usando Vagrant, instalar K3s y configurar un clúster de Kubernetes con (en este momento) un nodo &lt;em&gt;master&lt;/em&gt; y dos &lt;em&gt;workers&lt;/em&gt;. Como parte de la automatización, también despliego Longhorn como &lt;em&gt;storageClass&lt;/em&gt; .&lt;/p&gt;&#xA;&lt;p&gt;Hoy he testeado con éxito el despliegue de ArgoCD y Gitea en el clúster, dando un pasito adelante para desplegar una plataforma completa de desarrollo sobre Kubernetes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cliente API en Bash (con curl)</title>
      <link>https://onthedock.github.io/post/220617-cliente-api-en-bash/</link>
      <pubDate>Fri, 17 Jun 2022 20:46:13 +0200</pubDate>
      <guid>https://onthedock.github.io/post/220617-cliente-api-en-bash/</guid>
      <description>&lt;p&gt;En una entrada anterior, &lt;a href=&#34;https://onthedock.github.io/post/220518-obtener-respuesta-y-http-status-con-curl/&#34;&gt;Obtener respuesta y código de la petición HTTP con curl&lt;/a&gt;, explicaba cómo mejorar, en mi opinión, la &lt;em&gt;relación&lt;/em&gt; con la API desde los &lt;em&gt;scripts&lt;/em&gt; (en Bash) que se ejecutan desde una &lt;em&gt;pipeline&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;La idea que explicaba en el artículo era cómo usar el código HTTP devuelto por la función que expone la API para controlar posibles errores.&lt;/p&gt;&#xA;&lt;p&gt;Como prueba de concepto fue satisfactoria, pero no resulta práctica aplicarla; en un caso real se usan múltiples documentos y la repetición del mismo código una y otra vez hace que se alcance el límite de cuatro mil caracteres en un &lt;em&gt;paso&lt;/em&gt; de la &lt;em&gt;pipeline&lt;/em&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;Así que la solución es &lt;em&gt;encapsular&lt;/em&gt; esta idea en una función en vez de repetir el mismo código una y otra vez: &lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;Don&amp;rsquo;t repeat yourself&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sacando partido de la funcionalidad de jq</title>
      <link>https://onthedock.github.io/post/220519-jq/</link>
      <pubDate>Thu, 19 May 2022 20:05:53 +0200</pubDate>
      <guid>https://onthedock.github.io/post/220519-jq/</guid>
      <description>&lt;p&gt;Siguendo con el &lt;a href=&#34;https://onthedock.github.io/post/220518-obtener-respuesta-y-http-status-con-curl/&#34;&gt;tema de ayer&lt;/a&gt;, hoy quiero revisar otro bloque de código.&lt;/p&gt;&#xA;&lt;p&gt;En este caso, se construye un &lt;em&gt;array&lt;/em&gt; en JSON usando Bash &lt;em&gt;puro&lt;/em&gt;, cuando es el proceso se simplifica &lt;strong&gt;enormemente&lt;/strong&gt; gracias a la función &lt;code&gt;--slurp&lt;/code&gt; de &lt;code&gt;jq&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Obtener respuesta y código de la petición HTTP con curl</title>
      <link>https://onthedock.github.io/post/220518-obtener-respuesta-y-http-status-con-curl/</link>
      <pubDate>Wed, 18 May 2022 18:30:52 +0200</pubDate>
      <guid>https://onthedock.github.io/post/220518-obtener-respuesta-y-http-status-con-curl/</guid>
      <description>&lt;p&gt;Llevo una temporada revisando código -MUCHO, MUCHO código- en Bash.&lt;/p&gt;&#xA;&lt;p&gt;Como parte de uno de los &lt;em&gt;steps&lt;/em&gt; de ejecución de una &lt;em&gt;pipeline&lt;/em&gt;, se consulta una API para obtener o actualizar información de una base de datos y &lt;em&gt;hacer cosas&lt;/em&gt; con esa información, como desplegar recursos en un proveedor cloud (usando la &lt;em&gt;cli&lt;/em&gt;) o lanzando Terraform.&lt;/p&gt;&#xA;&lt;p&gt;Uno de los patrones que me encontrado a la hora de interaccionar con la API es el siguiente:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Generar el &lt;em&gt;payload&lt;/em&gt; en JSON y guardarlo en una variable.&lt;/li&gt;&#xA;&lt;li&gt;Ejecutar la petición usando &lt;code&gt;curl&lt;/code&gt; y guardar la respuesta en un fichero.&lt;/li&gt;&#xA;&lt;li&gt;Filtrar la respuesta usando &lt;code&gt;jq&lt;/code&gt; leyendo el fichero.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Sobre el uso de mayúsculas o minúsculas en los nombres de variables en Bash</title>
      <link>https://onthedock.github.io/post/220305-sobre-el-uso-de-mayusculas-o-minusculas-para-los-nombres-de-variables-en-bash/</link>
      <pubDate>Sat, 05 Mar 2022 11:30:49 +0100</pubDate>
      <guid>https://onthedock.github.io/post/220305-sobre-el-uso-de-mayusculas-o-minusculas-para-los-nombres-de-variables-en-bash/</guid>
      <description>&lt;p&gt;He estado buscando información sobre cuál es la manera correcta a la hora de definir los nombres de las variables en Bash&amp;hellip; Y como en el caso de la eterna batalla entre espacios vs tabs o Vim vs Emacs, parece que no hay una solución definitiva (o seguida por todo el mundo de forma generalizada).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Crear usuarios (usando recursos nativos) en Kubernetes 1.19&#43;</title>
      <link>https://onthedock.github.io/post/211205-crear-usuarios-usando-recursos-nativos-en-kubernetes-1.19/</link>
      <pubDate>Sun, 05 Dec 2021 19:57:28 +0100</pubDate>
      <guid>https://onthedock.github.io/post/211205-crear-usuarios-usando-recursos-nativos-en-kubernetes-1.19/</guid>
      <description>&lt;p&gt;Hace unas entradas, en &lt;a href=&#34;https://onthedock.github.io/post/211010-crear-usuarios-en-k3s/&#34;&gt;&#xA;Crear usuarios en Kubernetes (y en K3s)&lt;/a&gt;, escribía sobre cómo generar nuevos usuarios con acceso al clúster de Kubernetes usando un fichero &lt;code&gt;kubeconfig&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;El método descrito implicaba extraer fuera del clúster el certificado privado de la entidad certificadora (CA) de Kubernetes, lo que no me parecía la mejor solución.&lt;/p&gt;&#xA;&lt;p&gt;Desde Kubernetes 1.19 existe un nuevo recurso en la API, el &lt;code&gt;CertificateSigningRequest&lt;/code&gt;, que permite firmar certificados para proporcionar acceso (por ejemplo) al clúster.&lt;/p&gt;&#xA;&lt;p&gt;En esta entrada se describe cómo aprovechar esta nueva funcionalidad para dar acceso a un usuario usando un certificado firmado por la CA del clúster.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
