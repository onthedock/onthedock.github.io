<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on On The Dock</title>
    <link>https://onthedock.github.io/tags/git/</link>
    <description>Recent content in Git on On The Dock</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <lastBuildDate>Thu, 02 Nov 2023 20:46:08 +0100</lastBuildDate>
    <atom:link href="https://onthedock.github.io/tags/git/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Usa un script (y Gum) para crear tus Conventional Commits</title>
      <link>https://onthedock.github.io/post/231102-usa-un-script-y-gum-para-crear-tus-conventional-commits/</link>
      <pubDate>Thu, 02 Nov 2023 20:46:08 +0100</pubDate>
      <guid>https://onthedock.github.io/post/231102-usa-un-script-y-gum-para-crear-tus-conventional-commits/</guid>
      <description>&lt;p&gt;En la &lt;a href=&#34;https://onthedock.github.io/post/231101-plantilla-para-commits/&#34;&gt;entrada anterior&lt;/a&gt; mencionaba cómo usar una &lt;em&gt;plantilla&lt;/em&gt; para homogeneizar los &lt;em&gt;commits&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Además de la plantilla, usar &lt;a href=&#34;https://www.conventionalcommits.org/en/v1.0.0/&#34;&gt;Conventional Commits&lt;/a&gt; permite dotar de un &lt;em&gt;formato standard&lt;/em&gt; a los commits. La buena gente de &lt;a href=&#34;https://charm.sh/&#34;&gt;Charm&lt;/a&gt; ofrece como parte del &lt;a href=&#34;https://github.com/charmbracelet/gum&#34;&gt;tutorial para aprender a usar Gum&lt;/a&gt; un &lt;em&gt;script&lt;/em&gt; con el que redactar &lt;em&gt;conventional commits&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;En esta entrada, ofrezco una versión ampliada que incluye la descripción para cambios que rompen la &lt;em&gt;retrocompatibilidad&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Usa una plantilla para los commits de Git</title>
      <link>https://onthedock.github.io/post/231101-plantilla-para-commits/</link>
      <pubDate>Wed, 01 Nov 2023 18:16:45 +0100</pubDate>
      <guid>https://onthedock.github.io/post/231101-plantilla-para-commits/</guid>
      <description>&lt;p&gt;Git proporciona la opción de establecer un fichero como &lt;em&gt;plantilla&lt;/em&gt; para los &lt;em&gt;commits&lt;/em&gt; de Git.&lt;/p&gt;&#xA;&lt;p&gt;Cuando defines una plantilla para los &lt;em&gt;commits&lt;/em&gt;, al ejecutar &lt;code&gt;git commit&lt;/code&gt;, el editor que tengas configurado para componer el mensaje de &lt;em&gt;commmit&lt;/em&gt; carga automáticamente la plantilla que hayas definido.&lt;/p&gt;&#xA;&lt;p&gt;Ni que decir que usar una plantilla para todos los &lt;em&gt;commits&lt;/em&gt; ayuda a homogeneizar los mensajes en el repositorio y es una configuración esencial en equipos de trabajo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git: Cómo comparar ficheros en ramas diferentes #til</title>
      <link>https://onthedock.github.io/post/230618-git-como-comparar-ficheros-en-ramas-diferentes-til/</link>
      <pubDate>Sun, 18 Jun 2023 07:06:08 +0200</pubDate>
      <guid>https://onthedock.github.io/post/230618-git-como-comparar-ficheros-en-ramas-diferentes-til/</guid>
      <description>&lt;p&gt;Imagina que te encuentras en el siguiente escenario: creas un rama y haces cambios en un fichero.&lt;/p&gt;&#xA;&lt;p&gt;¿Cómo puedes ver qué diferencias hay en el fichero en dos ramas distintas?&lt;/p&gt;&#xA;&lt;p&gt;La solución es mi #TIL (&lt;em&gt;today I learn&lt;/em&gt;) de hoy.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git sparse-checkout para clonar sólo subcarpeta(s) de un repositorio</title>
      <link>https://onthedock.github.io/post/230309-git-sparse-checkout/</link>
      <pubDate>Thu, 09 Mar 2023 19:41:48 +0100</pubDate>
      <guid>https://onthedock.github.io/post/230309-git-sparse-checkout/</guid>
      <description>&lt;p&gt;El ejemplo habitual para introducir los &lt;em&gt;sparse checkouts&lt;/em&gt; es cuando todo el código de un equipo se encuentra en un &lt;em&gt;mono repo&lt;/em&gt;, es decir, un repositorio &lt;strong&gt;para todo&lt;/strong&gt;.&#xA;En el repositorio cada &amp;ldquo;carpeta&amp;rdquo; contiene el código de un microservicio, por ejemplo&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;En esta situación, un miembro del equipo tiene que clonar el repositorio entero aunque sólo tenga que trabajar en una parte muy pequeña del mismo, generalmente circunscrita a una funcionalidad que se encuentra en una carpeta del repositorio.&lt;/p&gt;&#xA;&lt;p&gt;Del mismo modo, para compilar el código de uno de los microservicios de este mono repo, es necesario clonarlo completamente&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;En este tipo de situaciones es cuando podemos usar &lt;code&gt;git sparse-checkout&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git desde Cero</title>
      <link>https://onthedock.github.io/post/220208-git-desde-cero-git-init/</link>
      <pubDate>Tue, 08 Feb 2022 20:00:48 +0100</pubDate>
      <guid>https://onthedock.github.io/post/220208-git-desde-cero-git-init/</guid>
      <description>&lt;p&gt;Un grupo de compañeros van a cambiar las tareas que realizan como parte de su trabajo; parte de esa transformación consiste en familiarizarse con el uso de  &lt;a href=&#34;https://git-scm.com/&#34;&gt;Git&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;He decidido &lt;em&gt;darle una vuelta&lt;/em&gt; a cómo les introduciría en el uso de Git de manera sencilla y que &lt;em&gt;tenga sentido&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cómo combinar commits en Git (squash)</title>
      <link>https://onthedock.github.io/post/210121-combinar-commits/</link>
      <pubDate>Sun, 31 Jan 2021 09:33:38 +0100</pubDate>
      <guid>https://onthedock.github.io/post/210121-combinar-commits/</guid>
      <description>&lt;p&gt;Las buenas prácticas (por ejemplo &lt;a href=&#34;https://www.git-tower.com/learn/git/ebook/en/command-line/appendix/best-practices/&#34;&gt;Version Control Best Practices&lt;/a&gt;) relacionadas con el control de versiones usando Git indican que hay que guardar (&lt;em&gt;commit&lt;/em&gt;) los cambios de forma frecuente, conteniendo únicamente pequeños cambios.&lt;/p&gt;&#xA;&lt;p&gt;Sin embargo, el desarrollo no se produce de una forma lineal, de principio a fin; a veces, lo que parece una buena idea que funciona al principio, más adelante es necesario cambiarla o modificarla&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;Si guardamos todos los &lt;em&gt;commits&lt;/em&gt;, la historia del repositorio quedará llena de estos cambios de dirección durante el desarrollo. Por este motivo, una de las opciones que tenemos es la de reescribir la historia del repositorio antes de, por ejemplo, hacer &lt;em&gt;merge&lt;/em&gt; de la rama de &lt;em&gt;feaure&lt;/em&gt; sobre la rama principal.&lt;/p&gt;&#xA;&lt;p&gt;En este artículo vemos cómo conseguirlo usando &lt;code&gt;git rebase&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>gitmoji: Emojis en los mensajes de commit</title>
      <link>https://onthedock.github.io/post/200711-gitmoji-emojis-en-los-mensajes-de-commit/</link>
      <pubDate>Sat, 11 Jul 2020 08:01:56 +0200</pubDate>
      <guid>https://onthedock.github.io/post/200711-gitmoji-emojis-en-los-mensajes-de-commit/</guid>
      <description>&lt;p&gt;Revisando los repositorios del diseñador original del tema de este blog, &lt;a href=&#34;https://github.com/dim0627&#34;&gt;Daisuke Tsuji&lt;/a&gt; he encontrado el fichero &lt;a href=&#34;https://github.com/dim0627/dotfiles/blob/master/.git_commit_message&#34;&gt;&lt;code&gt;.git_commit_message&lt;/code&gt;&lt;/a&gt; que contiene una lista de emojis:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Múltiples repositorios remotos en Git</title>
      <link>https://onthedock.github.io/post/200512-multiples-repositorios-remotos-en-git/</link>
      <pubDate>Tue, 12 May 2020 22:06:13 +0200</pubDate>
      <guid>https://onthedock.github.io/post/200512-multiples-repositorios-remotos-en-git/</guid>
      <description>&lt;p&gt;Al clonar un repositorio, Git añade una referencia en la configuración del repositorio clonado para incluir el repositorio &amp;ldquo;original&amp;rdquo; como &amp;ldquo;remote&amp;rdquo;. Este repositorio se denomina, por defecto, &lt;code&gt;origin&lt;/code&gt;. De esta forma, si quieres enviar cambios a este repositorio, ejecutas el comando &lt;code&gt;git push origin ${rama}&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;En algunas situaciones te puede interesar trabajar con múltiples repositorios remotos, por lo que en esta entrada explico cómo revisar los repositorios remotos configurados en tu repositorio, cómo añadir y eliminar repositorios &amp;ldquo;remotos&amp;rdquo; adicionales, cambiarles el nombre, etc.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gestionar múltiples identidades en Git</title>
      <link>https://onthedock.github.io/post/200509-gestionar-multiples-identidades-en-git/</link>
      <pubDate>Sat, 09 May 2020 18:46:35 +0200</pubDate>
      <guid>https://onthedock.github.io/post/200509-gestionar-multiples-identidades-en-git/</guid>
      <description>&lt;p&gt;He encontrado este artículo &lt;a href=&#34;https://www.sep.com/sep-blog/2019/01/03/automatically-keeping-git-identities-distinct-between-accounts/&#34;&gt;Automatically keeping Git identities distinct between accounts&lt;/a&gt; hojeando el blog de la empresa &lt;a href=&#34;https://www.sep.com/&#34;&gt;SEP&lt;/a&gt; después de leer un artículo sobre &lt;em&gt;testing&lt;/em&gt; de plantillas de CloudFormation.&lt;/p&gt;&#xA;&lt;p&gt;La configuración que indica Aaron Alexander en el artículo referenciado permite usar una identidad concreta para cada cuenta de Git.&lt;/p&gt;&#xA;&lt;p&gt;Esto te permite identificarte con tu cuenta de empresa en los repositorios de la empresa, en los personales con una dirección de correo personal, etc.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gitea: la versión mejorada de Gogs</title>
      <link>https://onthedock.github.io/post/180713-gitea-la-version-mejorada-de-gogs/</link>
      <pubDate>Fri, 13 Jul 2018 20:04:36 +0200</pubDate>
      <guid>https://onthedock.github.io/post/180713-gitea-la-version-mejorada-de-gogs/</guid>
      <description>&lt;p&gt;Gogs es un servidor web de repositorios Git (a lo GitHub). He hablado otras veces de lo sencillo que es montarlo usando Docker, de manera independiente (&lt;a href=&#34;https://onthedock.github.io/post/171106-gogs-como-crear-tu-propio-servicio-de-hospedaje-de-repos-git/&#34;&gt;usando SQLite&lt;/a&gt; como base de datos o &lt;a href=&#34;https://onthedock.github.io/post/180520-pipeline-gogs-el-repositorio-de-codigo/&#34;&gt;con MySQL&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;A través de este artículo &lt;a href=&#34;https://www.cyberciti.biz/open-source/github-alternatives-open-source-seflt-hosted/&#34;&gt;6 Github alternatives that are open source and self-hosted&lt;/a&gt; descubrí hace unos días &lt;a href=&#34;https://gitea.io&#34;&gt;Gitea&lt;/a&gt; y a continuación te explico porqué creo que es todavía mejor que Gogs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gogs - Cómo crear tu propio servicio de hospedaje de repositorios Git</title>
      <link>https://onthedock.github.io/post/171106-gogs-como-crear-tu-propio-servicio-de-hospedaje-de-repos-git/</link>
      <pubDate>Mon, 06 Nov 2017 22:11:26 +0100</pubDate>
      <guid>https://onthedock.github.io/post/171106-gogs-como-crear-tu-propio-servicio-de-hospedaje-de-repos-git/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gogs.io/&#34;&gt;Gogs&lt;/a&gt; es la manera más sencilla, rápida y menos dolorosa de poner en marcha tu propio servicio de Git en tu infraestructura, tu propio &lt;em&gt;Github&lt;/em&gt;, para entendernos. Gogs proporciona un entorno web que permite gestionar los respositorios Git desde el navegador, el acceso que tienen los usuarios, gestionar &lt;em&gt;issues&lt;/em&gt; y &lt;em&gt;pull requests&lt;/em&gt; e incluso crear un wiki para documentar el proyecto.&lt;/p&gt;&#xA;&lt;p&gt;Es 100% código abierto, está escrito en Go y es &lt;em&gt;muy ligero&lt;/em&gt; (incluso puede correr en una Raspberry Pi).&lt;/p&gt;&#xA;&lt;p&gt;En este artículo te indico cómo confirgurarlo lanzándolo desde un contenedor sobre Docker.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Normas para estructurar ficheros implicados en la creación de contenedores</title>
      <link>https://onthedock.github.io/post/170520-normas-para-estructurar-ficheros-implicados-en-la-creacion-de-contenedores/</link>
      <pubDate>Sat, 20 May 2017 19:59:44 +0200</pubDate>
      <guid>https://onthedock.github.io/post/170520-normas-para-estructurar-ficheros-implicados-en-la-creacion-de-contenedores/</guid>
      <description>&lt;p&gt;El proceso desde la creación a la ejecución del contenedor se puede separar en varias fases:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Creación de la imagen (mediante la redacción de un fichero &lt;code&gt;Dockerfile&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Construcción de la imagen&lt;/li&gt;&#xA;&lt;li&gt;Ejecución del contenedores&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Para tener los diferentes ficheros implicados en el proceso organizados de forma homogénea, me he autoimpuesto las siguientes reglas a la hora de estructurar los repositorios.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
